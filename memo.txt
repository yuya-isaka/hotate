参考：chibiscv(kivantium-core), chibi-risc-v(kivantium-core), ChiselProjectsIsaka(Pencilrocket、動かせたやつ？),  riscv-processor-hashi, riscv-book(chisel本井阪勉強)
古い：RV32
新しい：hotate(kivantium-core参考に作ってるやつ), first(Pencilrocketを参考に自分で作ってるやつ)

hotateはパラメータを利用してモジュールに引数渡したり、色々工夫できている。

やりたいこと
最低限の確認（シミュレーション上、FPGA実機）
・M拡張がちゃんと動いているかチェックする（fac.c）
・ノイマン型にしてみる（動く？）
シリアル通信
・Uartをhotateで処理できる機構を追加（まずは送信だけで良い）
・minicomを使って通信して、hotateでC言語の"Hello World"を表示させる
	・デバイスドライバがない場合、特定のアドレスに書き込むってする（メモリマップドI/O）。ある場合シリアル通信用の関数が用意されていて、その関数の中身では同じようにアドレスへの書き込みなどが行われているかもしれないが、それをユーザが意識せずにできるようにしている。）これがデバイスドライバファイルの役割
OSを利用してシリアル通信
・割込み命令（CSR,ECALL）
・RISC-V用のOS（RISC-V OSを作ろう、と、KOZOSの移植を参考に）
・RISC-V用のOSを動かしてターミナルを出し、そこで入力したデータをエコーバックする処理ができれば嬉しい
OSを利用してネットワーク通信
・LANコントローラを利用

継続
SystemVerilogを用いてRISC-Vを作ってるあの書籍のコードを参考に、改良
・パイプライン
・キャッシュメモリ
・ノイマン型


目標
・https://github.com/riscv-software-src/riscv-tests/tree/master/benchmarks
・RISC-V標準ベンチマークアプリケーションを爆速実行できるCPUとOSを作る。

改善案
・全体,ファイル名と変数名
・全体,型のパラメータ化(https://qiita.com/taichi-ishitani/items/ceee94d612c10bd08376)
・top,Topにメモリ移動
・top,Topでコアとメモリポート接続
・top,7segをモジュール化
・top,クロックの変更
・top,クロックのパラメータ化
・core,ステートをenumで定義,型のパラメータ化と一緒に(https://qiita.com/taichi-ishitani/items/ceee94d612c10bd08376)
・core,PC設定
・core,PCをリセット
・core,レジスタをコアで定義
・registerFile,コアに移動
・registerFile,読み込むレジスタをデコードに移動
・registerFile,書き込みをWBに移動
・dataとinstMemoryを統合,依存性の注入,インスタンス化で切り替える(https://qiita.com/taichi-ishitani/items/03b13589431c5213b968)
・dataMemory,べき乗演算
・dataMemory,定数定義
・dataMemory,データメモリの大きさ
・instructionMemory,べき乗演算
・instructionMemory,定数定義
・instructionMemory,命令メモリの大きさ
・instructionMemory,`default_nettype none
・executeInteger,デコードに幾つかコード移動
・executeInteger,演算処理パラメータで綺麗に
・executeInteger,ALUの最適化(https://qiita.com/triggerfish/items/54cb06461124b5b19064)
・executeInteger,funct3,funct7の使い方
・instructionDecoder,ListLookup的に処理したい,構造体を作成
・instructionDecoder,insideをBitPatのように使える->ListLookup的にできる
・instructionDecoder,funct3,funct7の使い方
・instructionDecoder,inside使って比較演算子書き換えられる
・instructionDecoder,1,0のところ変えたい

加工案
・FPGAマガジンを参考に構成変更
・FPGAマガジンを参考にキャッシュ作成
・ステートマシンを変更
・パイプライン
・M拡張追加
・CSR命令追加
・ECALL命令追加
・ハーバードからノイマン型へ
・xfpのuartを移植(pythonと通信)

目標
・xv6が動くCPU(xv6が2019年からRISC-Vに対応)
・OSを動かすために割り込みや特権命令，スーパーバイザーモードでの仮想アドレスを実装する必要あり


makefile 他のパターン
--------------------------------------------------------------
CC := riscv32-unknown-linux-gnu-gcc
LD := riscv32-unknown-linux-gnu-ld
OBJCOPY := riscv32-unknown-linux-gnu-objcopy
OBJDUMP := riscv32-unknown-linux-gnu-objdump
CFLAGS := -march=rv32ima -c

main: $(ARG).hex $(ARG).dump
	./hex2bin.sh $(ARG).hex > $(ARG).b

$(ARG).hex: $(ARG).bin
	hexdump -v -e '/4 "%08X" "\n"' $(ARG).bin > $(ARG).hex

$(ARG).bin: $(ARG).elf
	$(OBJCOPY) -O binary $(ARG).elf $(ARG).bin

$(ARG).elf: $(ARG).o start.o
	$(LD) $(ARG).o start.o -Tlink.ld -nostartfiles -static -o $(ARG).elf

start.o: start.S
	$(CC) $(CFLAGS) -o start.o start.S

$(ARG).o: $(ARG).S
	$(CC) $(CFLAGS) -o $(ARG).o $(ARG).S

$(ARG).S: $(ARG).c
	$(CC) $(CFLAGS) -S -o $(ARG).S $(ARG).c

$(ARG).dump: $(ARG).elf
	$(OBJDUMP) -d $(ARG).elf > $(ARG).dump

clean:
	$(RM) *.o *.out *.bin *.elf
----------------------------------------------------------------

Verilator
VCDファイル
テストベンチでVCD波形ダンプをONにする
verilator --cc --exe  --trace --trace-params --trace-structs --trace-underscore top.sv -exe tb_hotate.cpp
make -C obj_dir -f Vtop.mk
./obj_dir/Vtop

FSTファイル
テストベンチでFST波形ダンプ
verilator --cc --exe  --trace-fst --trace-params --trace-structs --trace-underscore top.sv -exe tb_hotate.cpp
make -C obj_dir -f Vtop.mk
./obj_dir/Vtop

Lint
verilator --lint-only -Wall top.sv

_______________
Verilatorの使い方
1. https://msyksphinz.hatenablog.com/entry/2020/05/06/040000
2. https://msyksphinz.hatenablog.com/entry/2020/05/08/040000
3. https://msyksphinz.hatenablog.com/entry/2020/05/10/000000
4. https://msyksphinz.hatenablog.com/entry/2020/05/12/040000



kivantiumさんのverilog文法について
・https://kivantium.hateblo.jp/entry/2016/09/17/191638

verilog文法について
・http://japanese.sugawara-systems.com/tutorial/verilog/framepage7.htm
・https://dora.bk.tsukuba.ac.jp/~takeuchi/?%E9%9B%BB%E6%B0%97%E5%9B%9E%E8%B7%AF%2FHDL%2FVerilog%E3%81%A7%E7%8A%AF%E3%81%97%E3%81%8C%E3%81%A1%E3%81%AA%E8%A8%98%E8%BF%B0%E3%83%9F%E3%82%B9

Vivado Tclスクリプト
・https://qiita.com/ikwzm/items/a0120079d2f7f86a5904


RISC-Vのコードモデルについて
・https://msyksphinz.hatenablog.com/entry/2020/05/04/040000
・https://msyksphinz.hatenablog.com/entry/2020/05/05/040000


自作CPU＆自作OSをやっていく(そんなに参考にならんかも、chisel)
・https://laysakura.github.io/2020/01/31/handcraft-cpu-os-1/
・https://laysakura.github.io/2020/02/03/handcraft-cpu-os-2/
・https://laysakura.github.io/2020/02/09/handcraft-cpu-os-3/


自作CPUの話、勉強になる
UARTについてとか
・https://travelingresearcher.com/entry/2018/02/27/172417

RustでRISC-V OS自作
・https://qiita.com/tomoyuki-nakabayashi/items/76f912adb6b7da6030c7
64bit版
・https://laysakura.github.io/2020/02/03/handcraft-cpu-os-2/

RISC-V testの挙動
・https://laysakura.github.io/2020/02/09/handcraft-cpu-os-3/

Rustで始める自作組み込みOS
・https://garasubo.github.io/embedded-book/

色々まとめ
・https://www.notion.so/OS-etc-Wiki-a4461ce365ca46808ba88e8343435ee1

RISC Vに従うCPUの上で動作するOSをRustで書く（CPU実験余興）
・https://moraprogramming.hateblo.jp/entry/2019/03/17/165802
↓
これを参考に、RISC-Vに従うCPUの上で動作するKOZOSをRustで書く
ってのができるかも

RISC-V OSを作ろう
・https://valinux.hatenablog.com/entry/20210527

KOZOSをRISC-Vに移植したやつもあったはず


自作RISC-Vコアにおける浮動小数点命令サポートの検討
・https://msyksphinz.hatenablog.com/entry/2022/02/13/040000
自作CPUコアでは命令定義をJSONで管理して、デコーダを自動生成するようにしている
浮動小数点レジスタファイルの追加
浮動小数点演算としては、オープンソースのFPUとしてFPNewを使用

RISC-V命令拡張の考え方について
・https://msyksphinz.hatenablog.com/entry/2017/10/15/020000

キャッシュの話
・https://gist.github.com/wanabe/3fc111a4665e60d3e0dc25a6e46a333d

Verilatorとか独自に書き換えてオプションとか追加してるの笑う
・https://msyksphinz.hatenablog.com/entry/2021/03/26/040000

Verilator以外のシミュレーション、Vivado
hassyさんもこの方法だった
・https://msyksphinz.hatenablog.com/entry/2021/02/11/040000


RISC-VコアとRAMを用意して、
RAMにELFファイルのデータを流し込む仕組み
SiFiveのDTMが使える。外部からデータをやりとりするためのポート
・https://msyksphinz.hatenablog.com/entry/2021/02/03/040000


標準ベンチマーク、CoreMark
プログラムの実行にかかったサイクル数が計測されスコアとして表示される
商用プロセッサ等とスコアを比較できる

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

resetボタンは用意しなくていいのか？
別になくてもいいみたい。多分未定義動作になってるな。


make push M="add makefile"


何個までBRAM使える？
https://scrapbox.io/htkymtks/%E4%BD%95%E5%80%8B%E3%81%BE%E3%81%A7BRAM%E3%82%92%E4%BD%BF%E3%81%88%E3%82%8B%EF%BC%9F

[Synth 8-6849] Infeasible attribute ram_style = “block” set for RAM “memory_array_name”,trying to implement using LUTRAM
との Warning が出て、 BRAM が推定されなかったことがわかります (LUTRAM はDistributed RAM のこと) 。

・LUTをやたら使っている理由がわからない。。。。。
Block RAMを使えていない理由はわからないけど、
とりあえずこれを参考にしてみた。
https://lpha-z.hatenablog.com/entry/2019/12/22/231500
でもrstを削除するのは特に関係ない気がする。。。
→ LUT減った。。。
けど他の、同期クロックの追加もしたからこれが理由かはわからないけど、多分これ
一応検証する。

memoryDataのみrstを変えて検証
rstあり LUT:83%
rstなし LUT:67%


あと　ram_style="block"の指定をしていると、推論されなかったときに指摘されるって書いてるけど
全然指摘してくれない。。。でもLUTの数は変わっている。不思議。



動作していないのは、クロックのタイミング制約の問題だと思う。



Vivado Warning
また、以下の設定もしておくとよいでしょう。

set_property BITSTREAM.CONFIG.UNUSEDPIN Pullup [current_design]
set_property CFGBVS <GND | VCCO> [current_design]
set_property CONFIG_VOLTAGE <1.8 | 2.5 | 3.3> [current_design]

CONFIG_VOLTAGE は Bank0 の VCCIO 電圧です。
1.8V ならば CFGBVS は GND、2.5V と 3.3V の場合は VCCO と指定します。ただし、これは指定しなくても動きますし、指定が間違っていても動くので効果のほどはわかりません。
[current_design] というのは、current_design というコマンドを実行して現在のデザインを示すオブジェクトを得ます。
このオブジェクトに対して BITSTREAM.CONFIG.** というプロパティを設定するものです。
current_design は、XDC でのコマンドであって、Tcl 本来の機能ではありません。

現在は、2.5, VCCOにしている。